[TOC]

# 编译原理代码

## 小C语言--词法分析程序

#### Problem Description

每行单词数不超过10个
小C语言文法如上，现在我们对小C语言写的一个源程序进行词法分析，分析出关键字、自定义标识符、整数、界符
和运算符。
关键字：main if else for while int
自定义标识符：除关键字外的标识符
整数：无符号整数
界符：{ } ( ) , ;
运算符：= + - * / < <= > >= == !=

#### Input

输入一个小C语言源程序，源程序长度不超过2000个字符，保证输入合法。

#### Output

按照源程序中单词出现顺序输出，输出二元组形式的单词串。

(单词种类,单词值)

单词一共5个种类：

关键字：用keyword表示
自定义标识符：用identifier表示
整数：用integer表示
界符：用boundary表示
运算符：用operator表示

每种单词值用该单词的符号串表示。

#### Sample Input

```
main() 
{
    int a, b;
    if(a == 10)
    {
        a = b;
    }
}
```

#### Sample Output

```
(keyword,main)
(boundary,()
(boundary,))
(boundary,{)
(keyword,int)
(identifier,a)
(boundary,,)
(identifier,b)
(boundary,;)
(keyword,if)
(boundary,()
(identifier,a)
(operator,==)
(integer,10)
(boundary,))
(boundary,{)
(identifier,a)
(operator,=)
(identifier,b)
(boundary,;)
(boundary,})
(boundary,})
```

#### code

```c++
#include <bits/stdc++.h>
using namespace std;

string T[6]={"main","if","else","for","while","int"};
string S[6]={"(keyword,","(identifier,","(integer,","(boundary,","(operator,"};

void judge(string s)
{
    if(!s.size())return;
    int f=1;
    if(s[0]>='0'&&s[0]<='9')
    {
        cout<<S[2]<<s<<")"<<endl;
    }
    else
    {
        for(int i=0;i<6;i++)
        {
            if(s==T[i])
            {
                f=0;
                cout<<S[0]<<s<<")"<<endl;
                break;
            }
        }
        if(f)cout<<S[1]<<s<<")"<<endl;
    }
}


int main()
{
    string s;
    while(cin>>s)
    {
        int len=s.size();
        string tmp;
        for(int i=0;i<len;i++)
        {
            if(s[i]=='='||s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/'||s[i]=='>'||s[i]=='<'||s[i]=='!')
            {
                judge(tmp);
                tmp="";
                if(s[i+1]=='='&&(i+1<len))
                {
                    cout<<S[4]<<s[i]<<s[i+1]<<")"<<endl;
                    i++;//!!提前判断，所以跳过下一个
                }
                else cout<<S[4]<<s[i]<<")"<<endl;
            }
            else if(s[i]=='{'||s[i]=='}'||s[i]=='('||s[i]==')'||s[i]==','||s[i]==';')
                {
                    judge(tmp);
                    tmp="";
                    cout<<S[3]<<s[i]<<")"<<endl;
                }
                else tmp+=s[i];
        }
        judge(tmp);

    }
    return 0;
}

```

## 表达式语法分析——递归子程序法

#### Problem Description

递归子程序法是一种确定的自顶向下语法分析方法，要求文法是LL(1)文法。它的实现思想是对应文法中每个非终结符编写一个递归过程，每个过程的功能是识别由该非终结符推出的串，当某非终结符的产生式有多个候选式时能够按LL(1)形式唯一地确定选择某个候选式进行推导。请根据下面的表达式LL(1)文法，构造递归子程序，完成对表达式的语法分析。

表达式文法如下：

  E→TG

  G→+TG | ε

  T→FS

  S→*FS | ε

  F→(E) | i


对于给定的输入串（长度不超过50个符号），请输出分析过程中用到的所有产生式，并指明该输入串是否为该文法能生成的表达式,输出共11行，前10行每行两个数据用空格隔开，表示推导时所用产生式顺序号（从0开始），最后一行是accept，表示i+i*i是文法能生成的合法表达式。注：其中&符号代表文法中的ε符号。
例如：

i+i*i是文法能生成的一个表达式,输出格式如下：

0 E-->TG

1 T-->FS

2 F-->i

3 S-->&

4 G-->+TG

5 T-->FS

6 F-->i

7 S-->*FS

8 F-->i

9 S-->&

10 G-->&

accept


i@i不是文法能生成的表达式，输出共5行，前5行每行两个数据用空格隔开，表示推导时所用产生式序号（从0开始），最后一行是error，表示i@i不是文法能生成的表达式。@不是合法的文法符号，输出格式举例：

0 E-->TG

1 T-->FS

2 F-->i

3 S-->&

4 G-->&

error

 

(i+i*i不是文法能生成的表达式，存在括号不匹配的语法错误，输出格式举例：

0 E-->TG

1 T-->FS

2 F-->(E)

3 E-->TG

4 T-->FS

5 F-->i

6 S-->&

7 G-->+TG

8 T-->FS

9 F-->i

10 S-->*FS

11 F-->i

12 S-->&

13 G-->&

error

#### Input

输入数据只有一行，代表待分析的符号串，以#号结束

#### Output

输出推导过程中所有的产生式，按照使用顺序给出。输出详细说明见题目描述中的例子。

#### Sample Input

```
i+i*i#
```

#### Sample Output

```
0 E-->TG
1 T-->FS
2 F-->i
3 S-->&
4 G-->+TG
5 T-->FS
6 F-->i
7 S-->*FS
8 F-->i
9 S-->&
10 G-->&
accept
```

#### code

```c++
#include <bits/stdc++.h>
using namespace std;
string a;
int p;
int flag=1;
int f=0;
void E();
void G();
void T();
void S();
void F();
void S()
{
    if(!flag)
        return;
    if(a[p]=='*')
    {
        printf("%d S-->*FS\n",f++);
        p++;
        F();
        S();
    }
    else
    {
        printf("%d S-->&\n",f++);
    }
}
void F()
{
    if(!flag)
        return;
    if(a[p]=='(')
    {
        printf("%d F-->(E)\n",f++);
        p++;
        E();
        if(a[p]!=')')
            flag=0;
        p++;
    }
    else if(a[p]=='i')
    {
        printf("%d F-->i\n",f++);
        p++;
    }
    else
        flag=0;//！！
}
void T()
{
    if(!flag)
        return;
    if(a[p]=='('||a[p]=='i')
        printf("%d T-->FS\n",f++);
    F();
    S();
}
void G()
{
    if(!flag)
        return;
    if(a[p]=='+')
    {
        printf("%d G-->+TG\n",f++);
        p++;
        T();
        G();
    }
    else
        printf("%d G-->&\n",f++);
}
void E()
{
    if(!flag)
        return;
    if(a[p]=='('||a[p]=='i')
        printf("%d E-->TG\n",f++);
    T();
    G();
}
int main()
{
    p=0;
    cin>>a;
    if(a.length()==0||(a.length()==1&&a[0]=='#'))
    {
        printf("error\n");
        return 0;
    }
    E();
    if(!flag)
        printf("error\n");
    else if(p!=a.length()-1)
        printf("error\n");
    else
        printf("accept\n");
    return 0;
}
```