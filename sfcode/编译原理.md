[TOC]

# 编译原理代码

## 小C语言--词法分析程序

#### Problem Description

每行单词数不超过10个
小C语言文法如上，现在我们对小C语言写的一个源程序进行词法分析，分析出关键字、自定义标识符、整数、界符
和运算符。
关键字：main if else for while int
自定义标识符：除关键字外的标识符
整数：无符号整数
界符：{ } ( ) , ;
运算符：= + - * / < <= > >= == !=

#### Input

输入一个小C语言源程序，源程序长度不超过2000个字符，保证输入合法。

#### Output

按照源程序中单词出现顺序输出，输出二元组形式的单词串。

(单词种类,单词值)

单词一共5个种类：

关键字：用keyword表示
自定义标识符：用identifier表示
整数：用integer表示
界符：用boundary表示
运算符：用operator表示

每种单词值用该单词的符号串表示。

#### Sample Input

```
main() 
{
    int a, b;
    if(a == 10)
    {
        a = b;
    }
}
```

#### Sample Output

```
(keyword,main)
(boundary,()
(boundary,))
(boundary,{)
(keyword,int)
(identifier,a)
(boundary,,)
(identifier,b)
(boundary,;)
(keyword,if)
(boundary,()
(identifier,a)
(operator,==)
(integer,10)
(boundary,))
(boundary,{)
(identifier,a)
(operator,=)
(identifier,b)
(boundary,;)
(boundary,})
(boundary,})
```

#### code

```c++
#include <bits/stdc++.h>
using namespace std;

string T[6]={"main","if","else","for","while","int"};
string S[6]={"(keyword,","(identifier,","(integer,","(boundary,","(operator,"};

void judge(string s)
{
    if(!s.size())return;
    int f=1;
    if(s[0]>='0'&&s[0]<='9')
    {
        cout<<S[2]<<s<<")"<<endl;
    }
    else
    {
        for(int i=0;i<6;i++)
        {
            if(s==T[i])
            {
                f=0;
                cout<<S[0]<<s<<")"<<endl;
                break;
            }
        }
        if(f)cout<<S[1]<<s<<")"<<endl;
    }
}


int main()
{
    string s;
    while(cin>>s)
    {
        int len=s.size();
        string tmp;
        for(int i=0;i<len;i++)
        {
            if(s[i]=='='||s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/'||s[i]=='>'||s[i]=='<'||s[i]=='!')
            {
                judge(tmp);
                tmp="";
                if(s[i+1]=='='&&(i+1<len))
                {
                    cout<<S[4]<<s[i]<<s[i+1]<<")"<<endl;
                    i++;//!!提前判断，所以跳过下一个
                }
                else cout<<S[4]<<s[i]<<")"<<endl;
            }
            else if(s[i]=='{'||s[i]=='}'||s[i]=='('||s[i]==')'||s[i]==','||s[i]==';')
                {
                    judge(tmp);
                    tmp="";
                    cout<<S[3]<<s[i]<<")"<<endl;
                }
                else tmp+=s[i];
        }
        judge(tmp);

    }
    return 0;
}

```

